= How Distributed Computing Works in Jet

In this section we will take a deep dive into the fundamentals of
distributed computing and Jet's specific take on it. We will do this by
dissecting one specific problem: the Word Count. This is how you'd
describe it in the {jet-samples}/batch/wordcount/src/main/java/WordCount.java[Jet Pipeline API]:

[source]
----
include::{javasource}/WhatIsDistributedComputing.java[tag=s1]
----

We'll step back from this and start from the single-threaded Java code
that solves the problem for a basic data structure such as an
`ArrayList` and gradually move on to a formulation that allows us to
solve it for a data source distributed over the whole cluster,
efficiently making use of all the available CPU power.

If you have some familiarity with the `java.util.stream` API, this is
how you'd express it:

[source]
----
include::{javasource}/WhatIsDistributedComputing.java[tag=s2]
----

You can notice a strong similarity with the Pipeline API formulation,
but the way it's executed is radically different. Java will compute it
in a single thread, basically running this code:

[source]
----
include::{javasource}/WhatIsDistributedComputing.java[tag=s3]
----

The `java.util.stream` formulation helps us see the steps taken to
process each data item:

1. `lines.stream()`: read the items (lines of text) from the data source
(we'll call this the "`source`" step).
2. `flatMap()`+`filter()`: split each line into lowercase words,
avoiding empty strings (the tokenizing step).
3. `collect()`: group equal words together and count them (the
accumulating step).

Our first move will be modeling the computation as a DAG. We'll start
with a single-threaded model and then make several transformation steps
to it to reach a parallelized, distributed one, discussing at each step
the concerns that arise and how to meet them.

== Modeling Word Count in terms of a DAG

We can represent the steps outlined above as a DAG:

image::wordcount-dag.png[Word-counting DAG,600,170]

The simplest, single-threaded code (shown above) deals with each item as
it is produced: the outer loop reads the lines, the inner loop that runs
for each line deals with the words on that line, and inside the inner
loop we populate the result map with running counts.

However, just by modeling the computation as a DAG, we've split the work
into isolated steps with clear data interfaces between them. We can
perform the same computation by running a separate thread for each step.
Roughly speaking, these are the snippets the threads would be executing:

[source]
// Source thread
for (String line : readLines()) {
    emit(line);
}

[source]
// Tokenizer thread
for (String line : receive()) {
    for (String word : line.toLowerCase().split("\\W+")) {
        if (!word.isEmpty()) {
            emit(word);
        }
    }
}

[source]
// Accumulator thread
Map<String, Long> counts = new HashMap<>();
for (String word : receive()) {
    counts.merge(word, 1L, (count, one) -> count + one);
}
// finally, when done receiving:
for (Entry<String, Long> wordAndCount : counts.entrySet()) {
    emit(wordAndCount);
}

The source loop feeds the tokenizer loop over a concurrent queue, the
tokenizer feeds the accumulator loop, and after the accumulator is done
receiving, it emits its results to the sink. Diagrammatically it looks
like this:

image::wordcount-dag-queue.png[Word-counting DAG with concurrent queues shown,600,170]


This transformation brought us a _pipelined_ architecture: while the
tokenizer is busy with the regex work, the accumulator is updating the
map using the data the tokenizer is done with; and the source and sink
stages are pumping the data from/to the environment. Our design is now
able to engage more than one CPU core and will complete that much
sooner; however, we're still limited by the number of vertices. We'll be
able utilize two or three cores regardless of how many are available. To
move forward we must try to parallelize the work of each individual
vertex.

Given that our input is an in-memory list of lines, the bottleneck
occurs in the processing stages (tokenizing and accumulating). Let's
first attack the tokenizing stage: it is a so-called "embarrassingly
parallelizable" task because the processing of each line is completely
self-contained. At this point we have to make a clear distinction
between the notions of _vertex_ and _processor_: there can be several
processors doing the work of a single vertex. Let's add another
tokenizing processor:

image::wordcount-tokenizer.png[Word-counting DAG with tokenizer vertex parallelized,600,170]


The input processor can now use all the available tokenizers as a pool
and submit to any one whose queue has some room.

The next step is parallelizing the accumulator vertex, but this is
trickier: accumulators count word occurrences so using them as a pool
will result in each processor observing almost all distinct words
(entries taking space in its hashtable), but the counts will be partial
and will need combining. The common strategy to reduce memory usage is
to ensure that all occurrences of the same word go to the same
processor. This is called "`data partitioning`" and in Jet we'll use a
_partitioned edge_ between the tokenizer and the accumulator:

image::wordcount-partitioned.png[Word-counting DAG with tokenizer and accumulator parallelized,600,170]


As a word is emitted from the tokenizer, it goes through a "`switchboard`"
stage where it's routed to the correct downstream processor. To
determine where a word should be routed, we can calculate its hashcode
and use the lowest bit to address either accumulator 0 or accumulator 1.

At this point we have a blueprint for a fully functional parallelized
computation job which can max out all the CPU cores given enough
instances of tokenizing and accumulating processors. The next challenge
is making this work across machines.

For starters, our input can no longer be a simple in-memory list because
that would mean each machine processes the same data. To exploit the
cluster as a unified computation device, each cluster member must
observe only a slice of the dataset. Given that a Jet instance is also a
fully functional Hazelcast IMDG instance and a Jet cluster is also a
Hazelcast IMDG cluster, the natural choice is to pre-load our data into
an `IMap`, which will be automatically partitioned and distributed
across the members. Now each Jet member can just read the slice of data
that was stored locally on it.

When run in a cluster, Jet will instantiate a replica of the whole DAG
on each member. On a two-member cluster there will be two source
processors, four tokenizers, and so on. The trickiest part is the
partitioned edge between tokenizer and accumulator: each accumulator is
supposed to receive its own subset of words. That means that, for
example, a word emitted from tokenizer 0 will have to travel across the
network to reach accumulator 3, if that's the one that happens to own
it. On average we can expect every other word to need network transport,
causing both serious network traffic and serialization/deserialization
CPU load.

There is a simple trick we can employ to avoid most of this traffic,
closely related to what we pointed above as a source of problems when
parallelizing locally: members of the cluster can be used as a pool,
each doing its own partial word counts, and then send their results to a
combining vertex. Note that this means sending only one item per
distinct word. Here's the rough equivalent of the code the combining
vertex executes:

[source]
// Combining vertex
Map<String, Long> combined = new HashMap<>();
for (Entry<String, Long> wordAndCount : receive()) {
    combined.merge(wordAndCount.getKey(), wordAndCount.getValue(),
                    (accCount, newCount) -> accCount + newCount);
}
// finally, when done receiving:
for (Entry<String, Long> wordAndCount : combined.entrySet()) {
    emit(wordAndCount);
}

As noted above, such a scheme takes more memory due to more hashtable
entries on each member, but it saves network traffic (an issue we didn't
have within a member). Given that memory costs scale with the number of
distinct keys (english words in our case), the memory cost is
more-or-less constant regardless of how much book material we process.
On the other hand, network traffic scales with the total data size so
the more material we process, the more we save on network traffic.

Jet distinguishes between _local_ and _distributed_ edges, so we'll use
a _local partitioned_ edge for `tokenize`->`accumulate` and a
_distributed partitioned_ edge for `accumulate`->`combine`. With this
move we've finalized our DAG design, which can be illustrated by the
following diagram:

image::wordcount-distributed.png[Word-counting DAG parallelized and distributed,600,170]

[[unbounded-stream-processing]]
== Unbounded Stream Processing

So far we've worked with an assumption of the bounded (finite)
stream processing model: you provide Jet with one or more pre-existing
datasets and order it to mine them for interesting information. The most
important workhorse in this area is the "join, group and aggregate"
operation: you define a classifying function that computes a grouping
key for each of the datasets and an aggregate operation that will be
performed on all the items in each group, yielding one result item per
distinct key.

=== The Importance of "`Right Now`"

In batch jobs the data we process represents a point-in-time snapshot of
our state of knowledge (for example, warehouse inventory where
individual data items represent items on stock). We can recapitulate
each business day by setting up regular snapshots and batch jobs.
However, there is more value hiding in the freshest data &mdash; our
business can win by reacting to minute-old or even second-old updates.
To get there we must make a shift from the finite to the infinite: from
the snapshot to a continuous influx of events that update our state of
knowledge. For example, an event could pop up in our stream every time
an item is checked in or out of the warehouse.

A single word that captures the above story is _latency_: we want our
system to minimize the latency from observing an event to acting upon
it.

=== Windowing

In an unbounded stream, the dimension of time is always there.  Consider
a batch job: it may process a dataset labeled "`Wednesday`", but the
computation itself doesn't have to know this. Its results will be
understood from the outside to be "`about Wednesday`". An endless stream,
on the other hand, delivers information about the reality as it is
unfolding, in near-real time, and the computation itself must deal with
time explicitly.

Another point: in a batch it is obvious when to stop aggregating and
emit the results: when we have exhausted the whole dataset. However,
with unbounded streams we need a policy on how to select bounded chunks
whose aggregate results we are interested in. This is called
_windowing_. We imagine the window as a time interval laid over the time
axis. A given window contains only the events that belong to that
interval.

A very basic type of window is the _tumbling window_, which can be
imagined to advance by tumbling over each time. There is no overlap
between the successive positions of the window. In other words, it
splits the time-series data into batches delimited by points on the time
axis. The result of this is very similar to running a sequence of batch
jobs, one per time interval.

A more useful and powerful policy is the _sliding window_: instead of
splitting the data at fixed boundaries, it lets it roll in
incrementally, new data gradually displacing the old. The window
(pseudo)continuously slides along the time axis.

Another popular policy is called the _session window_ and it's used to
detect bursts of activity by correlating events bunched together on the
time axis. In an analogy to a user's session with a web application,
the session window "`closes`" when the specified session timeout elapses
with no further events.

[[time-ordering]]
=== Time Ordering and the Watermark

Usually the time of observing an event is explicitly written in a field
of the stream item. There is no guarantee that items will occur in the
stream ordered by the value of that field; in fact in many cases it is
certain that they won't. Consider events gathered from users of a mobile
app: for all kinds of reasons the items will arrive to our datacenter
out of order, even with significant delays due to connectivity issues.

This disorder in the event stream makes it more difficult to formally
specify a rule that tells us at which point all the data for a given
window has been gathered, allowing us to emit the aggregated result.

To approach these challenges we use the concept of the
{jet-javadoc}/core/Watermark.html[_watermark_].
It is a timestamped item Jet inserts into the stream that says "from
this point on there will be no more items with timestamp less than
this". Unfortunately, we almost never know for sure when such a
statement becomes true and there is always a chance some events will
arrive even later. If we do observe such an offending item, we must
categorize it as "`too late`" and just filter it out.

Note the tension in defining the "`perfect`" watermark for a given use
case: it is bad both the more we wait and the less we wait to emit a
given watermark. The more we wait, the higher the latency of getting the
results of the computation; the less we wait, the worse their accuracy
due to missed events.

For these reasons Jet cannot determine the watermark on its own, you
must decide how much disorder to accept (and expect).

=== Fault Tolerance and Processing Guarantees

One less-than-obvious consequence of stepping up from finite to infinite
streams is the difficulty of forever maintaining the continuity of the
output, even in the face of changing cluster topology. A Jet node may
leave the cluster due to an internal error, loss of networking, or
deliberate shutdown for maintenance. This will cause the computation job
to be suspended. Except for the obvious problem of new data pouring in
while we're down, we have a much more fiddly issue of restarting the
computation in a differently laid-out cluster exactly where it left off
and neither miss anything nor process it twice. The technical term for
this is the "exactly-once processing guarantee".

Hazelcast Jet transparently coordinates the execution of submitted jobs.
One member is assigned the role of the _coordinator_. It tells other
members what to do and they report to it any status changes. The
coordinator may fail and the cluster will automatically re-elect another
one. If any other member fails, the coordinator restarts the job on the
remaining members.

In Jet, job submission works on the fire-and-forget principle: once you
have submitted it, you can disconnect with no effect on the job. Any
other client or Jet member can request a local `Job` instance which
allows it to monitor and manage the job.

