[[start-jet]]
= Start Jet

To create a Jet cluster, we simply start some Jet instances. Normally
these would be started on separate machines, but for simple practice
we can use the same JVM for two instances. Even though they are in the
same JVM, they'll communicate over the network interface.

[source]
----
include::{javasource}/StartJet.java[tag=s1]
----

These two instances should automatically discover each other using IP
multicast and form a cluster. You should see a log output similar to the
following:

....
Members [2] {
  Member [10.0.1.3]:5701 - f1e30062-e87e-4e97-83bc-6b4756ef6ea3
  Member [10.0.1.3]:5702 - d7b66a8c-5bc1-4476-a528-795a8a2d9d97 this
}
....

This means the members successfully formed a cluster. Since the Jet
instances start their own threads, it is important to explicitly shut
them down at the end of your program; otherwise the Java process will
remain alive after the `main()` method completes:

[source]
----
include::{javasource}/StartJet.java[tag=s2]
----

[[build-pipeline]]
= Build the Computation Pipeline

The general shape of any data processing pipeline is `drawFromSource ->
transform -> drainToSink` and the natural way to build it is from source
to sink. The <<pipeline-api, Pipeline API>> follows this pattern. For
example,

[source]
----
include::{javasource}/BuildComputation.java[tag=s1]
----

Refer to the chapter on the <<pipeline-api, Pipeline API>> for full
details.

[[job]]
= Submit a Jet Job and Manage its Lifecycle

This is how you submit a Jet pipeline for execution:

[source]
----
include::{javasource}/ManageJob.java[tag=s1]
----

If you want to submit a Core API DAG, the syntax is identical:

[source]
----
include::{javasource}/ManageJob.java[tag=s2]
----

Job submission is a fire-and-forget action: once a client submits it,
the job has a life of its own independent of the submitter. It can
disconnect and any other client or Jet member can obtain its own `Job`
instance that controls the same job.

You can use the same API to submit a job from either a client machine
or directly on an instance of a Jet cluster member. The same `Pipeline`
or `DAG` instance can be submitted for execution many times.

== JobConfig

To gain more control over how Jet will run your job, you can pass in a
`JobConfig` instance. For example, you can give your job a
human-readable name:

[source]
----
include::{javasource}/ManageJob.java[tag=s3]
----

== Remember that a Jet Job is Distributed

The API to submit a job to Jet is in a way deceptively simple: "just
call a method." As long as you're toying around with Jet instances
started locally in a single JVM, everything will indeed work. However,
as soon as you try to deploy to an actual cluster, you'll face the
consequences of the fact that your job definition must travel over the
wire to reach remote members which don't have your code on their
classpath.

Your custom code must be packaged with the Jet job. For simple examples
you can have everything in a single class and use code like this:

[source]
----
include::{javasource}/Considerations.java[tag=s1]
----

If you forget to do this, or don't add all the classes involved, you
may get a quite confusing exception:

[source]
----
java.lang.ClassCastException:
cannot assign instance of java.lang.invoke.SerializedLambda
to field com.hazelcast.jet.core.ProcessorMetaSupplier$1.val$addressToSupplier
of type com.hazelcast.jet.function.DistributedFunction
in instance of com.hazelcast.jet.core.ProcessorMetaSupplier$1
----

`SerializedLambda` actually declares `readResolve()`, which would
normally transform it into an instance of the correct functional
interface type. If this method throws an exception, Java doesn't report
it but keeps the `SerializedLambda` instance and continues the
deserialization. Later in the process it will try to assign it to
a field whose type is the target type of the lambda
(`DistributedFunction` in the example above) and at that point it will
fail with the `ClassCastException`. If you see this kind of error,
double-check the list of classes you have added to the Jet job.

For more complex jobs it will become more practical to first package the
job in a JAR and then use a command-line utility to submit it, as
explained next.

== Submit a Job from the Command Line

Jet comes with the `jet-submit.sh` script, which allows you to submit a
Jet job packaged in a JAR file. You can find it in the Jet distribution
zipfile, in the `bin` directory. On Windows use `jet-submit.bat`. To use
it, follow these steps:

* Write your `main()` method and your Jet code the usual way, but call
{jet-javadoc}/server/JetBootstrap.html[`JetBootstrap.getInstance()`]
instead of `Jet.newJetClient()` to acquire a Jet client instance.
* Create a runnable JAR which declares its `Main-Class` in `MANIFEST.MF`.

* Run your JAR, but instead of `java -jar jetjob.jar` use `jet-submit.sh
jetjob.jar`.

* The script will create a Jet client and configure it from
`hazelcast-client.xml` located in the `config` directory of Jet's
distribution. Adjust that file to suit your needs.

For example, write a class like this:

[source]
----
include::{javasource}/Considerations.java[tag=s2]
----

After building the JAR, submit the job:

----
$ jet-submit.sh jetjob.jar
----

== Manage a Submitted Job

`jet.newJob()` and `jet.getJob(jobId)` return a
{jet-javadoc}/Job.html[Job] object, which you can use to monitor the
job and change its status:

* {jet-javadoc}/Job.html#suspend--[Job.suspend]: the job will stop
running, but its metadata will be kept and it can be resumed later. Use
this for example if you want to restart the members one by one and you
don't want the job to restart multiple times in the meantime

* {jet-javadoc}/Job.html#resume--[Job.resume]: resumes a previously
suspended job

* {jet-javadoc}/Job.html#restart--[Job.restart]: stops and restarts the
job to make use of new members added to the cluster (if automatic
scaling is disabled)

* {jet-javadoc}/Job.html#cancel--[Job.cancel]: the job will stop
running and will be marked as completed. It cannot be restarted later

You can also get the job's name, configuration, and submission time via
`job.getName()`, `job.getConfig()`, and `job.getSubmissionTime()`.
`job.getStatus()` will give you the current status of the job (running,
failed, completed etc.). You can also call `job.getFuture()` to block
until the job completes and then get its final outcome (either success
or failure).

Jet does not support canceling the job with `future.cancel()`, instead
you must call `job.cancel()`. This is due to the mismatch in the
semantics between `future.cancel()` on one side and `job.cancel()` plus
`job.getStatus()` on the other: the future immediately transitions to
"`completed by cancellation`", but it will take some time until the
actual job in the cluster changes to that state. Not to confuse the
users with these differences we decided to make `future.cancel()` fail
with an exception.

== Get a List of All Submitted Jobs

Jet keeps an inventory of all the jobs submitted to it, including those
that have already completed. Access the full list with `jet.getJobs()`.
You can use any `Job` instance from that list to monitor and manage a
job, whether it was you or some other client that submitted it.

This example tells you what Jet has been up to in the last five minutes:

[source]
----
include::{javasource}/ManageJob.java[tag=s4]
----

To only return all jobs submitted with a particular name, you can call
`jet.getJobs(name)`, or `jet.getJob(name)` to get just the latest one.

Here's how you can check the statistics on a job named `my-job`:

[source]
----
include::{javasource}/ManageJob.java[tag=s5]
----

*Note:* data about about completed jobs are evicted after 7 days.
