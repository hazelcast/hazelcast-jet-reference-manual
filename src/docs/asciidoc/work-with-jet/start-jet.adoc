[[start-jet]]
= Start Jet and Submit Jobs to It

To create a Jet cluster, we simply start some Jet instances. Normally
these would be started on separate machines, but for simple practice
we can use the same JVM for two instances. Even though they are in the
same JVM, they'll communicate over the network interface.

[source]
----
public class WordCount {
    public static void main(String[] args) {
        JetInstance jet = Jet.newJetInstance();
        Jet.newJetInstance();
    }
}
----

These two instances should automatically discover each other using IP
multicast and form a cluster. You should see a log output similar to the
following:

[source,text]
----
Members [2] {
  Member [10.0.1.3]:5701 - f1e30062-e87e-4e97-83bc-6b4756ef6ea3
  Member [10.0.1.3]:5702 - d7b66a8c-5bc1-4476-a528-795a8a2d9d97 this
}
----

This means the members successfully formed a cluster. Since the Jet
instances start their own threads, it is important to explicitly shut
them down at the end of your program; otherwise the Java process will
remain alive after the `main()` method completes:

[source]
----
public class WordCount {
    public static void main(String[] args) {
        try {
            JetInstance jet = Jet.newJetInstance();
            Jet.newJetInstance();

            ... work with Jet ...

        } finally {
            Jet.shutdownAll();
        }
    }
}
----

This is how you submit a Jet pipeline for execution:

[source]
----
jet.newJob(pipeline).join();
----

Alternatively, you can submit a Core API DAG:

[source]
----
jet.newJob(dag).join();
----

Code samples with
{jet-samples}/refman/src/main/java/refman/WordCountRefMan.java[the pipeline]
and
{jet-samples}/refman/src/main/java/refman/WordCountCoreApiRefMan.java[the Core API DAG]
are available at our Code Samples repo.

== JobConfig

To gain more control over how Jet will run your job, you can pass in
a `JobConfig` instance. For example, you can give your job a human-
readable name:

[source]
----
JobConfig cfg = new JobConfig();
cfg.setName("my job");
jet.newJob(pipeline, cfg);
----

In the <<practical-considerations, Practical Considerations>> section
we'll deepen this story and explain how to use the `JobConfig` to
to submit a job to a Jet cluster in production.

== Manage a Submitted Job

`jet.newJob()` returns a `Job` object, which you can use to monitor the
job and change its status. You can get the job's name, configuration, and
submission time via `job.getName()`, `job.getConfig()`, and
`job.getSubmissionTime()` methods. `job.getStatus()` will give you the
current status of the job (running, failed, completed etc.). You can also
call `Job.getFuture()` to block until the job completes and then get its
final outcome (either success or failure).

Jet does not support canceling the job with `future.cancel()`, instead
you must call `job.cancel()`. This is due to the mismatch in the
semantics between `future.cancel()` on one side and `job.cancel()` plus
`job.getStatus()` on the other: the future immediately transitions to
"`completed by cancellation`", but it will take some time until the actual
job in the cluster changes to that state. Not to confuse the users with
these differences we decided to make `future.cancel()` fail with an
exception.

== Get a List of all Submitted Jobs

Jet keeps an inventory of all the jobs submitted to it, including those
that have already completed. Access the full list with `jet.getJobs()`.
You can use any `Job` instance from that list to monitor and manage a
job, whether it was you or some other client that submitted it.

To get a more focused list of jobs, you can call `jet.getJobs(name)` to
get all the jobs with that name that were submitted since Jet started,
or `jet.getJob(name)` to get just the latest such job.
